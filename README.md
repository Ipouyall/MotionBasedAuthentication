# Motion Based Authentication

This project is designed as CA2 of the Cyber Physics Systems at the University of Tehran, Spring 2024.

In this project, we designed a motion based authentication app for mobile devices that is able to set a motion pattern as the answer and requiring to repeat that pattern for authentication.

This project consists of steps below:

- Front-end: mostly developed on QML and is capable of interacting with users. Assigned to **Pouya**
- Back-end: this part is consists of interacting with sensors, noise filtering and the logic of the app. Assigned to **Sina** and **Ali**.
- Analyzing performance: Using tools such as [Perfetto](https://ui.perfetto.dev/) to analysis proposes. Assigned to **Sepehr**
- Documentation and questions: Assigned to all members and it's been done by all of them.

---

## Front end

Our front-end is developed using QML and is capable of interacting with users. It's designed to be simple and user-friendly. It has several part, from top to bottom:

- In-line log: this part is designed to show the log of the app. It's designed to be simple and user-friendly. It can use different colors and designed reports authentication's result.
- Visualize patter: this part is designed to show the pattern that user should repeat. It has two *Graphical* and *Textual* mode, which can be changed by a slider.
- Control buttons: this part is designed to control the app. It has different buttons to interact with the app.

### Code structure

We can be divided the code into two parts: The Cpp codes, which are able to run the front-end and the QML codes, which are the main part of the front-end.
In the cpp part, we register the QML main entry in main.cpp and introduce the `MotionBasedAuth` object to the QML, this way it would be visible in the QML code.

```cpp
qmlRegisterType<MotionBasedAuth> ("MotionBasedAuthentication", 1, 0, "MotionBasedAuthentication");
...
const QUrl url(QStringLiteral("qrc:/MotionBasedAuthentication/Main.qml"));
```

The `MotionBasedAuth` is able to interact with the QML code using signals and slots. Q_Signals are used for sending signals to the QML and Q_Slots are used to ba called from the QML.

The main part is the QML codes. Our entry part is `Main.qml` which instantiates the ApplicationWindow component. Our main part in in `HomePage.qml`, which defines and place components of the application. It structures different parts and explained above. It also stablish a connection into back-end, the MotionBasedAuth class, used to control back and front interactions.

There exists another qml fine, named `PathDrawer.qml`. It contains a component used to draw a plot used in the Graphical view of the patters. This component is able to scale its input path. we used the default scale to $1000$ and the sensors values are low, but if the input pattern gets larger that the specified are, it would automatically scale it down to fit the specified area.

### Running the front-end

Here are some screenshots of the front-end:

#### Defining pattern

Start defining pattern:

![Start defining pattern](./Docs/figs/01_define%20pattern.jpg)

End defining pattern:

![End defining pattern](./Docs/figs/01_define%20pattern2.jpg)

#### On Successful attempt

Pop-up view:

![pop-up succeed](./Docs/figs/02_Succed%20Attempt.jpg)

Textual view:

![textual succeed](./Docs/figs/02_Succed%20Attempt2.jpg)

Graphical view:

![graph succeed](./Docs/figs/02_Succed%20Attempt3.jpg)

#### On Failed Attempt

Pop-up view:

![pop-up failed](./Docs/figs/03_Failed%20Attempt.jpg)

Textual view:

![textual failed](./Docs/figs/03_Failed%20Attempt2.jpg)

Graphical view:

![graph failed](./Docs/figs/03_Failed%20Attempt3.jpg)

---

## Back-end

The Motion-Based Authentication System leverages the motion data generated by sensors commonly found in modern smartphones and wearable devices. By analyzing unique motion patterns, users can authenticate themselves more securely and conveniently, reducing reliance on traditional authentication methods.

This system comprises four main components:

### 1. AccelerometerHandler

The `AccelerometerHandler` class is responsible for handling the accelerometer sensor data. It reads the sensor values, applies calibration, calculates velocity and distance, and emits path data when motion is detected.

#### Key Methods
- `start()`: Starts the accelerometer and reading timer.
- `stop()`: Stops the accelerometer and reading timer.
- `reset()`: Resets all internal states and recalibrates the sensor.

#### Signals
- `pathDataReady(double deltaX, double deltaY, double deltaZ)`: Emitted when a path segment is detected.

#### Additional Details
- `Calibration`: Performs initial calibration to account for device orientation and gravitational force.
- `Velocity and Distance Calculation`: Utilizes integration techniques to calculate velocity and distance based on acceleration data.
- `Path Detection`: Determines when a significant motion path segment occurs and emits signals accordingly.

### 2. GyroscopeHandler

The `GyroscopeHandler` class handles the gyroscope sensor data. It reads the angular velocity, calculates angular displacement, and rounds angles to the nearest multiple of 90 degrees when movement stops.

#### Key Methods
- `start()`: Starts the gyroscope and reading timer.
- `stop()`: Stops the gyroscope and reading timer.
- `reset()`: Resets all internal states.
- `getAngleZ()`: Returns the rounded Z-axis angle.

#### Additional Details
- `Angular Displacement`: Integrates angular velocity readings over time to calculate angular displacement.
- `Angle Rounding`: Rounds angular displacement to the nearest multiple of 90 degrees for easier interpretation and comparison.
- `Stability Detection`: Identifies when the device is stationary to differentiate between intentional motion and random movement.

### 3. SensorHandler

The `SensorHandler` class integrates data from both the accelerometer and gyroscope handlers. It processes the path data, calculates directions, and stores path segments.

#### Key Methods
- `start()`: Starts both accelerometer and gyroscope handlers.
- `stop()`: Stops both accelerometer and gyroscope handlers.
- `reset()`: Resets all internal states and paths.
- `getPaths()`: Returns the recorded paths.

#### Signals
- `newPathAdded(QVector<Path> newPath)`: Emitted when a new path is added.

#### Additional Details
- `Path Integration`: Combines data from the accelerometer and gyroscope to construct a continuous motion path.
- `Direction Calculation`: Determines the direction of motion based on changes in sensor readings over time.
- `Path Segmentation`: Divides the motion path into segments corresponding to distinct movements or gestures.

### 4. MotionBasedAuth

The `MotionBasedAuth` class provides the main interface for the authentication system. It records motion patterns, compares attempts with stored patterns, and determines authentication success.

#### Key Methods
- `startPattern()`: Starts recording the authentication pattern.
- `endPattern()`: Ends recording the authentication pattern and stores it.
- `startRecording()`: Starts recording a user's motion attempt.
- `endRecording()`: Ends recording the attempt and initiates authentication.
- `authenticate()`: Compares the recorded attempt with the stored pattern.

#### Signals
- `statusChanged(bool result)`: Emitted when authentication status changes.
- `dataChanged(QString data)`: Emitted when formatted data is ready.
- `pathChanged(QJsonArray path)`: Emitted when path data is available.

Additional Details:
- `Pattern Recording`: Allows users to record their unique motion patterns during the enrollment phase.
- `Authentication`: Compares recorded motion patterns with stored templates to authenticate users during login attempts.
- `Data Management`: Manages the storage and retrieval of authentication data, including recorded patterns and authentication attempts.
- `User Feedback`: Provides feedback to users regarding the success or failure of authentication attempts.

### Usage

1. **Start Pattern Recording**
   - Call `startPattern()` to begin recording the authentication pattern.
   - Call `endPattern()` to stop recording and store the pattern.

2. **Record an Attempt**
   - Call `startRecording()` to begin recording a user's attempt.
   - Call `endRecording()` to stop recording and initiate the authentication process.

3. **Authentication**
   - The `authenticate()` method will compare the attempt with the stored pattern and emit `statusChanged` with the result.

4. **Show Data**
   - Call `showData()` to format and display the stored authentication data and attempts.

### Pattern validation


The pattern validation part in the provided code is implemented in the MotionBasedAuth class. Let's break down how this approach works:

#### Pattern Recording

 When the user initiates pattern recording through the startPattern() method, the MotionBasedAuth class sets a flag (is_auth_pattern) to indicate that the pattern is being recorded. It then resets the sensor handler (sensorHandler) and starts it. The sensor handler collects data from the accelerometer and gyroscope.

#### Pattern Recording Termination
 When the user ends the pattern recording using the endPattern() method, the sensor handler stops, and the recorded paths are retrieved from the sensor handler using sensorHandler->getPaths(). These paths represent the motion pattern performed by the user during the recording phase.

#### Pattern Authentication
 During authentication, the MotionBasedAuth class compares the recorded pattern with the attempted pattern. This comparison is done in the comparePaths() method. The method iterates over each pair of paths in the recorded pattern and the attempted pattern.

#### Path Comparison
 For each pair of paths, the comparePaths() method checks if the start and end points of the paths are within a certain tolerance of each other. If they are not, it indicates a mismatch and returns a JSON object with an error message and an authentication status of false.

#### Authentication Result
 If all paths in the recorded pattern match their corresponding paths in the attempted pattern within the defined tolerance, the authentication is considered successful, and the method returns a JSON object with an empty error message and an authentication status of true.

#### Signal Emission
 After comparing the patterns, the authentication result is emitted through the statusChanged() signal, indicating whether the authentication was successful or not.
 
---

## Perfetto

---
